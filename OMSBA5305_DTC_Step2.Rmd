---
title: "R Notebook"
output: html_notebook
---

# Load Libraries
```{r}
library(readxl)
library(dynlm) # use the dynlm package
library(ggplot2)
library(dplyr)
```

#Import data and declare time series
Declaration: An Excel file named "ch3_UnemploymentRate.xls" is read using read_excel(). The data is then divided into the first 90% portion (data_first_90pct) and the estimation sample (data_estimation_sample). A time series object g is created based on the "UNRATE" column.
```{r}
data<- read_excel("ch3_UnemploymentRate.xls")
data_first_90pct <- data[1:ceiling(0.9*data_row_ct),]
data_estimation_sample <- tail(data, data_row_ct-ceiling(0.9*data_row_ct))

data_row_ct <- nrow(data)
data_first_90pct_row_ct <- nrow(data_first_90pct)
data_estimation_sample_row_ct <- data_row_ct-ceiling(0.9*data_row_ct)
g <- ts(data$UNRATE, frequency = 12, start=c(1948,1)) #declare g as (monthly) time series

```


## Model 1: AR(3) (Fixed Scheme): 
An AR(3) model is fitted to the estimation sample using dynlm(). The model is summarized, and a for loop is used to generate forecasts (fcast1) and forecast errors (ferror1) based on the model coefficients. The mean squared error (MSE) is calculated (MSE1). The model is then tested for forecast optimality using the MPE test and the informational efficiency test.
```{r}
fcast1<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror1<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss1<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)

model<-dynlm(g ~ lag(g,-1)+ lag(g,-3), start=c(1948,1), end=c(2023,2)) #fit AR(3)
summary(model)



for (i in 1:data_estimation_sample_row_ct){ #start a for loop
  fcast1[i]<-coef(model)[1]
    + coef(model)[2]*g[data_first_90pct_row_ct-1+i]
    + coef(model)[3]*g[data_first_90pct_row_ct-3+i] #fill in forecasted values at the end of each iteration
  ferror1[i]<-g[data_first_90pct_row_ct+i]- fcast1[i] #fill in forecasted values at the end of each iteration
  loss1[i] <-ferror1[i]^2
} #end the loop

cbind(fcast1, ferror1, loss1)
MSE1 <- mean(loss1)

mpetest <- lm(ferror1 ~ 1)
summary(mpetest)

IETest <- lm(ferror1 ~ fcast1)
summary(IETest)
```

## Model 2: Naive Forecast: 
A naive forecast is generated by assigning the previous observation as the forecast value (fcast2). Forecast errors and MSE are calculated, and the model is tested for forecast optimality.
```{r}
fcast2<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror2<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss2<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)

for (i in 1:data_estimation_sample_row_ct){ 
  fcast2[i]<-g[data_first_90pct_row_ct-1+i] #naive forecast
  ferror2[i]<-g[data_first_90pct_row_ct+i]- fcast2[i] #fill in forecasted values at the end of each iteration
  loss2[i] <-ferror2[i]^2
 } 
cbind(fcast2, ferror2, loss2)
MSE2 <- mean(loss2)

mpetest <- lm(ferror2 ~ 1)
summary(mpetest)


IETest <- lm(ferror2 ~ fcast2)
summary(IETest)

```


#Model 3: Average-4 Forecast: 
The forecast is calculated as the average of the last four observations (fcast3). Forecast errors and MSE are calculated, and the model is tested for forecast optimality.
```{r}
fcast3<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror3<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss3<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)


for (i in 1:data_estimation_sample_row_ct){ 
  fcast3[i]<-(g[data_estimation_sample_row_ct-1+i]
              +g[data_estimation_sample_row_ct-2+i]
              +g[data_estimation_sample_row_ct-3+i]
              +g[data_estimation_sample_row_ct-4+i]
            )/4  #forecast is the average of the last 4 observations
  ferror3[i]<-g[data_estimation_sample_row_ct+i] - fcast3[i] #fill in forecasted values at the end of each iteration
  loss3[i] <-ferror3[i]^2
}


cbind(fcast3, ferror3, loss3)
MSE3 <- mean(loss3)

mpetest <- lm(ferror3 ~ 1)
summary(mpetest)


IETest <- lm(ferror3 ~ fcast3)
summary(IETest)

```



## Optimal Linear Combinations: 
An optimal linear combination of the three forecasts is created using the lm() function (comb). The fitted values of the combination model are used as the forecast values (fcast4). Forecast errors and MSE are calculated for this combined forecast (ferror4, loss4, and MSE4).
```{r}

g0<-window(g,start=c(2015,9)) ## estimation sample date
comb<-lm(g0~fcast1+fcast2+fcast3)
summary(comb)


fcast4<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror4<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss4<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)

fcast4 <- comb$fitted.values
ferror4 <- g0-fcast4
loss4 <-ferror4^2

MSE4 <- mean(loss4)
```

# Plots
```{r}
forec <- cbind(data_estimation_sample,fcast1, fcast2, fcast3, fcast4)
## Adjust date tye
forec$observation_date = as.Date(forec$observation_date)
data$observation_date = as.Date(data$observation_date)
```
## Full Timeseries Plot + Forecast
```{r}
plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=3.0)+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")+
  lines(x = forec$observation_date, y= forec$fcast4,lty=2,lwd=2,col="purple")

```

## Estimation Sample Plot
```{r}

plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=5.0, xlim=c(as.Date("2015-01-01"), as.Date("2023-01-04")) )+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")+
  lines(x = forec$observation_date, y= forec$fcast4,lty=2,lwd=2,col="purple")

```



```{r}
plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=5.0, xlim=c(as.Date("2020-01-01"), as.Date("2023-01-04")) )+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")+
  lines(x = forec$observation_date, y= forec$fcast4,lty=2,lwd=2,col="purple")

```




