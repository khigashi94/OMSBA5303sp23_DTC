---
title: "OMSBA5305 Data Translation Challenge, R Code"
output: html_notebook
---

# Load Libraries
```{r}
library(readxl)
library(dynlm) # use the dynlm package
library(urca) #use urca package, allows choosing drift and/or trend for ADF test
library(ggplot2)
library(stats)
```

#Import data and declare time series
```{r}
data<- read_excel("ch3_UnemploymentRate.xls")

unrate <- ts(data$UNRATE, frequency = 12, start=c(1948,1)) #declare unrate as (monthly) time series
unrate_forecast <- ts(data$UNRATE, frequency = 12, start=c(1948,1), end = c(2023,2)) #declare g as (monthly) time series
```

# Step 1

## Remove Trend and Seasonality
```{r}
unrate_d12 <- diff(unrate, differences = 12)
plot(unrate_d12)
```

## Create ACF & PACF
```{r}
acf(unrate_d12)
pacf(unrate_d12)

acf(unrate)
pacf(unrate)
```

## Create Linear Models
### Linear MA Model
```{r}
MA <- arima(unrate, order = c(0,0,1))
print(MA)

```

### Linear AR Model
```{r}
AR <- arima(unrate, order = c(1,0,0))
print(AR)
```

### Linear ARMA Model
```{r}
ARMA <- arima(unrate, order = c(1,0,1))
print(ARMA)
```

## Verify White Noise Process (Q-Test)
```{r}
Box.test(unrate, type='Ljung-Box')
```



#Step 2

#Import data and declare time series
Declaration: An Excel file named "ch3_UnemploymentRate.xls" is read using read_excel(). The data is then divided into the first 90% portion (data_first_90pct) and the estimation sample (data_estimation_sample). A time series object unrate_forecast is created based on the "UNRATE" column.
```{r}
data_row_ct <- nrow(data)
data_first_90pct <- data[1:ceiling(0.9*data_row_ct),]
data_first_90pct_row_ct <- nrow(data_first_90pct)
data_estimation_sample <- tail(data, data_row_ct-ceiling(0.9*data_row_ct))
data_estimation_sample_row_ct <- data_row_ct-ceiling(0.9*data_row_ct)
```


## Model 1: AR(3) (Fixed Scheme): 
An AR(3) model is fitted to the estimation sample using dynlm(). The model is summarized, and a for loop is used to generate forecasts (fcast1) and forecast errors (ferror1) based on the model coefficients. The mean squared error (MSE) is calculated (MSE1). The model is then tested for forecast optimality using the MPE test and the informational efficiency test.
```{r}
fcast1<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror1<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss1<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)

model<-dynlm(unrate_forecast ~ lag(unrate_forecast,-1) + lag(unrate_forecast,-3), start=c(1948,1), end=c(2023,2)) #fit AR(3)
summary(model)

for (i in 1:data_estimation_sample_row_ct){ #start a for loop
  fcast1[i]<-coef(model)[1]+ coef(model)[2]*unrate_forecast[data_first_90pct_row_ct-1+i] + coef(model)[3]*unrate_forecast[data_first_90pct_row_ct-3+i] #fill in forecasted values at the end of each iteration
  ferror1[i]<-unrate_forecast[data_first_90pct_row_ct+i]- fcast1[i] #fill in forecasted values at the end of each iteration
  loss1[i] <-ferror1[i]^2
} #end the loop

# cbind(fcast1, ferror1, loss1)
MSE1 <- mean(loss1)

mpetest <- lm(ferror1 ~ 1)
summary(mpetest)


IETest <- lm(ferror1 ~ fcast1)
summary(IETest)
```


## Model 2: Naive Forecast: 
A naive forecast is generated by assigning the previous observation as the forecast value (fcast2). Forecast errors and MSE are calculated, and the model is tested for forecast optimality.
```{r}
fcast2<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror2<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss2<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)

for (i in 1:data_estimation_sample_row_ct){ 
  fcast2[i]<-unrate_forecast[data_first_90pct_row_ct-1+i] #naive forecast
  ferror2[i]<-unrate_forecast[data_first_90pct_row_ct+i]- fcast2[i] #fill in forecasted values at the end of each iteration
  loss2[i] <-ferror2[i]^2
 } 
cbind(fcast2, ferror2, loss2)
MSE2 <- mean(loss2)

mpetest <- lm(ferror2 ~ 1)
summary(mpetest)


IETest <- lm(ferror2 ~ fcast2)
summary(IETest)

```


#Model 3: Average-4 Forecast: 
The forecast is calculated as the average of the last four observations (fcast3). Forecast errors and MSE are calculated, and the model is tested for forecast optimality.
```{r}
fcast3<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror3<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss3<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)


for (i in 1:data_estimation_sample_row_ct){ 
  fcast3[i]<-(unrate_forecast[data_estimation_sample_row_ct-1+i]+unrate_forecast[data_estimation_sample_row_ct-2+i]+unrate_forecast[data_estimation_sample_row_ct-3+i]+unrate_forecast[data_estimation_sample_row_ct-4+i])/4  #forecast is the average of the last 4 observations
  ferror3[i]<-unrate_forecast[data_first_90pct_row_ct+i] - fcast3[i] #fill in forecasted values at the end of each iteration
  loss3[i] <-ferror3[i]^2
}


cbind(fcast3, ferror3, loss3)
MSE3 <- mean(loss3)

mpetest <- lm(ferror3 ~ 1)
summary(mpetest)


IETest <- lm(ferror3 ~ fcast3)
summary(IETest)

```



## Optimal Linear Combinations: 
An optimal linear combination of the three forecasts is created using the lm() function (comb). The fitted values of the combination model are used as the forecast values (fcast4). Forecast errors and MSE are calculated for this combined forecast (ferror4, loss4, and MSE4).
```{r}

unrate_forecast0<-window(unrate_forecast,start=c(2015,9)) ## estimation sample date
comb<-lm(unrate_forecast0~fcast1+fcast2+fcast3)
summary(comb)


fcast4<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
ferror4<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)
loss4<-numeric(data_estimation_sample_row_ct) #generate a vector of zeros (length of estimation sample set)

fcast4 <- comb$fitted.values
ferror4 <- unrate_forecast0-fcast4
loss4 <-ferror4^2

MSE4 <- mean(loss4)
```

# Forecasts Findings Overview
```{r}
data_estimation_sample
cbind(data_estimation_sample, fcast1, ferror1, loss1, fcast2, ferror2, loss2, fcast3, ferror3, loss3)
```

# Plots
```{r}
forec <- cbind(data_estimation_sample,fcast1, fcast2, fcast3, fcast4)
## Adjust date tye
forec$observation_date = as.Date(forec$observation_date)
data$observation_date = as.Date(data$observation_date)
forec
```
## Full Timeseries Plot + Forecast
```{r}
plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=3.0)+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")
# +
#   lines(x = forec$observation_date, y= forec$fcast4,lty=2,lwd=2,col="purple")

```

## Estimation Sample Plot
```{r}

plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=5.0, xlim=c(as.Date("2015-01-01"), as.Date("2023-01-04")) )+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")
# +
#   lines(x = forec$observation_date, y= forec$fcast4,lty=2,lwd=2,col="purple")

```



```{r}
plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=5.0, xlim=c(as.Date("2020-01-01"), as.Date("2023-01-04")) )+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")
# +
#   lines(x = forec$observation_date, y= forec$fcast4,lty=2,lwd=2,col="purple")

```

```{r}
plot(x = data$observation_date, y = data$UNRATE, type = "l", lwd=5.0, xlim=c(as.Date("2021-01-01"), as.Date("2023-01-04")) )+
  lines(x = forec$observation_date, y= forec$fcast1,lty=2,lwd=2,col="green")+
  lines(x = forec$observation_date, y= forec$fcast2,lty=2,lwd=2,col="red")+
  lines(x = forec$observation_date, y= forec$fcast3,lty=2,lwd=2,col="orange")

```

## Forcasted Data Plot
```{r}
ggplot() + 
  geom_line(data, mapping=aes(x=observation_date, y=UNRATE),size=1) +
  geom_line(forec, mapping=aes(x=observation_date, y=fcast1, color= 'Model 1: Fixed Scheme'),size=1) +
  geom_line(forec, mapping=aes(x=observation_date, y=fcast2, color='Model 2: Naive'),size=1) +
  geom_line(forec, mapping=aes(x=observation_date, y=fcast3, color='Model 3: Average-4'),size=1) +
  #geom_line(forec, mapping=aes(x=observation_date, y=fcast4, color='fcast4'),size=1) +
  xlim(as.Date(c("2015-01-01", "2023-01-01"))) +
  labs(title="GDP Forecast", colour="Forecasts") +
  xlab("Date") +
  ylab("GDP MoM% Rate")
```

## Forcasted Data Plot
```{r}
ggplot() + 
  geom_line(data, mapping=aes(x=observation_date, y=UNRATE),size=1) +
  geom_line(forec, mapping=aes(x=observation_date, y=fcast1, color= 'Model 1: Fixed Scheme'),size=1) +
  geom_line(forec, mapping=aes(x=observation_date, y=fcast2, color='Model 2: Naive'),size=1) +
  geom_line(forec, mapping=aes(x=observation_date, y=fcast3, color='Model 3: Average-4'),size=1) +
  #geom_line(forec, mapping=aes(x=observation_date, y=fcast4, color='fcast4'),size=1) +
  xlim(as.Date(c("1948-01-01", "2023-01-01"))) +
  labs(title="GDP Forecast", colour="Forecasts") +
  xlab("Date") +
  ylab("GDP MoM% Rate")+
  theme(aspect.ratio=1/2)
```



# Part 3
## Part 1 Simulation ###
```{r}
#P258 Generate time trend
t=c(1:50) #generate t=1,2,...50
y=1+.5*t+rnorm(50) #y=1+.5*trend + normal white noise
ts.plot(y) #plot y
lines(.5*t) #also plot the trend


#P271 Generate randm walk
y=numeric(500) #generate a vector of 500 zeros
for (i in 2:500){ #start a for loop
  y[i]=y[i-1]+rnorm(1) #generate random walk without drift
} #end the loop
ts.plot(y) #plot y
lines(numeric(500)) #also plot horizontal line at zero

ts.plot(cumsum(rnorm(500))) #another way to generate random walk without drift


y=numeric(500) #generate a vector of 500 zeros
for (i in 2:500){ 
  y[i]=.5+y[i-1]+rnorm(1) #generate random walk with drift
}
ts.plot(y) #plot y
lines(.5*c(1:500)) #also plot trend .5*t


# P277 model for case I, showin in fig10.8a (You should run this serveral times to see the variation)
y=numeric(500) #generate a vector of 500 zeros
for (i in 2:500){ 
  y[i]=0.9988*y[i-1]+rnorm(1) #generate random walk without drift
}
ts.plot(y) #plot y
lines(0*c(1:500)) #also plot trend .5*t

# P277 model for case II 
y=numeric(500) #generate a vector of 500 zeros
for (i in 2:500){ 
  y[i]=-0.325+0.9905*y[i-1]+rnorm(1) #generate random walk with drift
}
ts.plot(y) #plot y
lines(0*c(1:500)) #also plot trend .5*t

# P277 model for case III showin in fig10.8b
y=numeric(500) #generate a vector of 500 zeros
for (i in 2:500){ 
  y[i]=0.9167+0.0082i+0.9830*y[i-1]+rnorm(1) #generate random walk with drift and a time trend
}
ts.plot(y) #plot y
lines(0*c(1:500)) #also plot trend .5*t

## Part 2 Deterministic trend  ###
#P266
library(readxl)
data <- read_excel("Figure10_5_MortgageDebt.xls")
debt<-ts(data$`MORTGAGE DEBT`, frequency =4, start = c(1992,1)) #declare debt as quarterly time series
plot(debt)

trend1 = ts(c(1:49), frequency = 4, start = c(1992,1)) #trend1=1,2,3...60, declared to be time-series
model <-lm(debt ~ poly(trend1, 4, raw=TRUE)) # y=b0+b1*t+b2*t^2+b3*t^31+b4*t^4+WN
summary(model) #estimation output

AIC(model) #AIC
## [1] 434.5619
BIC(model) #BIS
## [1] 445.9129

plot.ts(debt, ylab="", lty=2) #plot debt w/o y-axis title, dashed
fit = ts(fitted(model), frequency = 4, start=c(1992,1)) #declare fit as quarterly time series
res = ts(resid(model), frequency = 4, start=c(1992,1)) #declare res as quarterly time series
lines(fit, col="red", lty=2) #also plot fit in red color
par(new=TRUE) #following series will be graphed on the existing plot
plot.ts(res, axes=FALSE, ylab="", col="blue") #plot residuals w/o y-axis title, in blue color
axis(side=4, at = pretty(range(res))) #add the right y-axis for residuals
legend("topleft", legend=c("Actual", "Fit", "Res"), lty=c(2,2,1), col=c("black", "red", "blue")) #legend, debt and fit will be dashed 

acf(res) #ACF of residuals of the 4th order polynomial trend model
pacf(res) #PACF of residuals of the 4th order polynomial trend model

#P268
#install.packages("dynlm") #install dynamic linear modelling package
library(dynlm) #dynlm is required for using lag operators
model <- dynlm(debt ~ trend1+I(trend1^2)+I(trend1^3)+I(trend1^4)+lag(debt,-1)+lag(debt,-2)) #AR(2) + polynomial(4) trend
summary(model) #estimation output

AIC(model) #AIC
## [1] 394.7132
BIC(model) #BIS
## [1] 409.5144

#P269

plot.ts(debt, ylab="", lty=2) #plot debt w/o y-axis title, dashed
fit = ts(fitted(model), frequency = 4, start=c(1992,3)) #declare fit as quarterly time series, note that fitted values start drom 1992q3 because it is an AR(2) model
res = ts(resid(model), frequency = 4, start=c(1992,1)) #declare res as quarterly time series
lines(fit, col="red", lty=2) #also plot fit in red color
par(new=TRUE) #following series will be graphed on the existing plot
plot.ts(res, axes=FALSE, ylab="", col="blue") #plot residuals w/o y-axis title, in blue color
axis(side=4, at = pretty(range(res))) #add the right y-axis for residuals
legend("topleft", legend=c("Actual", "Fit", "Res"), lty=c(2,2,1), col=c("black", "red", "blue")) #legend, debt and fit will be dashed 


## Part 3 Dickey-Fuller Test   ###
#P283
#install.packages("urca") #Unit Root and Cointegration Tests for Time Series Data
library(urca) #use urca package, allows choosing drift and/or trend for ADF test

ur.df(unrate,type="drift",lags=0) 
ur.df(diff(unrate),type="drift",lags=0) 
ur.df(diff(diff(unrate)),type="drift",lags=0) 

dunrate<-diff(unrate)
model_dickey_fuller <-dynlm(dunrate ~ lag(unrate,-1)) #regression correspondong to the above ADF test
summary(model_dickey_fuller) #estimation output
AIC(model_dickey_fuller)
## [1] 171.2994
BIC(model_dickey_fuller)
## [1] 175.6966
res_dickey_fuller<-  residuals(model_dickey_fuller) #generate residuals
acf(res_dickey_fuller)
pacf(res_dickey_fuller)

#P286

ur.df(unrate,type="drift",lags=1) 

model_lag1 <-dynlm(dunrate ~ lag(unrate,-1)+lag(dunrate,-1)) #regression corresponding to the above ADF test
summary(model_lag1)

AIC(model_lag1)
## [1] 134.9974
BIC(model_lag1)
## [1] 140.7334
res_lag1<-  residuals(model_lag1)
acf(res_lag1)
pacf(res_lag1)


# P287 Prepare to forecast table 10.8 
model_ar1 <-dynlm(dunrate ~ lag(dunrate,-1)+0) #AR(1) w/o constant for differenced series
summary(model_ar1)
AIC(model_ar1)
## [1] 135.857
BIC(model_ar1)
## [1] 138.725

fcast_ar1=union(unrate, c(1,2,3,4)) #fcast will include actual SPAIN and 4 forecasts for SPAIN
fcastd_ar1=union(dunrate, c(1,2,3,4)) #fcastd will include actual dSPAIN and 4 forecasts for dSPAIN

for(i in 1:4){
  fcastd_ar1[32+i]=coef(model_ar1)[1]*fcastd_ar1[31+i] #manually retrieving forecasts from AR(1) model for dSPAIN
  fcast_ar1[33+i]=fcast_ar1[32+i]+fcast_ar1[32+i] #the forecast for fcast_t = fcast_t-1 +fcastd_t (note that fcastd is one period "behind", thats why the last term is fcastd[32+i], and not fcastd[33+i])
}

# P288, fig 10.13
fcast = ts(fcast, frequency = 1, start = 1970)
ts.plot(fcast) #plot of the forecast
lines(SPAIN, col=6) #simualtaneous plotting of the actual series in magenta color


#P289 do the same for the u.s.
ur.df(USA,type="trend",lags=1) #ADF for USA with trend and constat
model <- dynlm(diff(USA) ~ lag(USA,-1)+diff(lag(USA,-1))+trend(USA)) #corresponding regression
summary(model)
AIC(model)
## [1] 104.6664
BIC(model)
## [1] 111.8363
model <- dynlm(USA ~ lag(USA,-1)+lag(USA,-2)+trend(USA)) #AR(2) with trend and constant
summary(model)
AIC(model)
## [1] 104.6664
BIC(model)
## [1] 111.8363
```


